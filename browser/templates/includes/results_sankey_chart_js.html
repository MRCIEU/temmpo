{# Includes the json_url template variable #}
<script>
    // Generate Sankey diagram
    google.charts.load("current", {packages: ["sankey"]});
    google.charts.setOnLoadCallback(function() { (getLinks(topVal))});

    function getAllIndexes(arr, val) {
        var indexes = [], i = -1;
        while ((i = arr.indexOf(val, i + 1)) != -1) {
            indexes.push(i);
        }
        return indexes;
    }

    topVal = 50
    function getLinks(topVal) {
        var threshold = topVal;
        var exp_int = [];
        var int_out = [];
        var oLinks = [];
        var sData = [];
        d3.json("{{ json_url }}").then(function (matches) {
            //create arrays of target and sources
            matches.links = matches.links.filter(function (link) {
                exp_int.push(link.target);
                int_out.push(link.source);
                return link;
            })
            //find overlapping link objects
            for (i in exp_int) {
                var int_out_match = int_out.indexOf(exp_int[i]);
                var indexes = getAllIndexes(int_out, exp_int[i]);
                if (indexes.length > 0) {
                    for (j in indexes) {
                        var o = {oNode: exp_int[i], l1: parseInt(i), l2: indexes[j]};
                        oLinks.push(o);
                    }
                }
            }
            //calculate scores based on number of abstracts for overlapping links
            for (i in oLinks) {
                var l1_val = matches.links[oLinks[i].l1].value;
                var l2_val = matches.links[oLinks[i].l2].value;
                if (l1_val > l2_val) {
                    var score = l2_val / l1_val * (l1_val + l2_val);
                } else {
                    var score = l1_val / l2_val * (l1_val + l2_val);
                }
                oLinks[i].score = score;
            }

            // //sort the objects by score
            var oLinksSort = oLinks.sort(function (a, b) {
                return b.score - a.score;
            })

            console.log(oLinksSort);

            if (threshold != -1 && oLinksSort.length > threshold) {
                console.log("Limiting links to " + threshold + " instead of showing " + oLinksSort.length);
                topLinks = oLinksSort.slice(0, threshold);
                // TODO change the way it's counted to ensure we get n mediators
                // TODO Would if JSON denoted mediators help?
            }
            else
            {
                topLinks = oLinksSort;
            }

            var top_sources = [];
            var top_targets = [];
            for (i in topLinks) {
                t1 = matches.links[topLinks[i].l1].target;
                s1 = matches.links[topLinks[i].l1].source;
                t2 = matches.links[topLinks[i].l2].target;
                s2 = matches.links[topLinks[i].l2].source;
                top_sources.push(s1, s2);
                top_targets.push(t1, t2);
            }
            nodeMatch = []

            matches.links = matches.links.filter(function (link) {
                // TODO Maybe should look up missing data and expand to ensure we have

                if (top_targets.indexOf(link.target) > -1 && top_sources.indexOf(link.source) > -1) {
                    nodeMatch.push(link.target, link.source);
                    target = matches.nodes[link.target].name;
                    source = matches.nodes[link.source].name;
                    sData.push([source, target, link.value]);
                }
            });
            // Hide the slider if we are not limiting the result set
            if (topLinks.length < 5) {
                $("#threshold-controller").hide();
            }

            drawSankeyDiagram(sData);
        });
    }

    function drawSankeyDiagram(sData) {
        var data = new google.visualization.DataTable();
        var s1Name = 'a'
        var s2Name = 'b'
        var maxCounter = 0

        data.addColumn('string', 'From');
        data.addColumn('string', 'To');
        data.addColumn('number', 'Articles');
        data.addRows(sData)

        // Set chart options
        var options = {
            width: "100%",
            height: 650,
            sankey: {
                node: {
                    interactivity: true,
                    label: {
                        fontName: '"Helvetica Neue",Helvetica,Arial,sans-serif',
                        fontSize: 12,
                    }
                }
            }
        };

        // Instantiate and draw our chart, passing in some options.
        var chart = new google.visualization.Sankey(document.getElementById('sankey_multiple'));
        chart.draw(data, options);

    }
    $(document).ready(function () {

        $(function () {
            $("#slider").slider({
                range: "max",
                min: 5,
                max: 500,
                value: 50,
                slide: function (event, ui) {
                    $("#chart-slider-label").val(ui.value);
                    google.charts.setOnLoadCallback(function() { (getLinks(ui.value))});
                }
            });
            $("#chart-slider-label").val($("#slider").slider("value"));
        });
    })
</script>